name;ring;quadrant;isNew;description;;;;;;;;;;;;;;;;;;;;;
5G Campus Netzwerk;Adopt;Techniques;1;Beschreibung 5G Campus Netzwerke;;;;;;;;;;;;;;;;;;;;;
IP Mesh;Adopt;Techniques;0;IP Mesh Netzwerke;;;;;;;;;;;;;;;;;;;;;
Technik 3;Trial;Techniques;-1;Technik 3;;;;;;;;;;;;;;;;;;;;;
WiFi;Trial;Techniques;FALSCH;WiFi als maîgliches Netz;;;;;;;;;;;;;;;;;;;;;
DECT;Adopt;Techniques;FALSCH;Wie wÑre es mit dect;;;;;;;;;;;;;;;;;;;;;
Technik 1;Trial;Techniques;FALSCH;Technik 1;;;;;;;;;;;;;;;;;;;;;
Der Test;Hold;Techniques;WAHR;"Dann schreibe ich da mal einen lÑngeren Text um zu prÅfen, wie es auf der Anzeige wirkt.<p>
<p>das wÑre dann die zweite Zeile
<p> - AufzÑhlung 1
<p> - AufzÑhlung 2 <a href=""https://docs.greatexpectations.io/en/latest/""><strong>Great Expectations</strong></a>";;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;
Technik 10;Assess;Techniques;WAHR;Technik 10;;;;;;;;;;;;;;;;;;;;;
Technik 11;Assess;Techniques;FALSCH;Technik 11;;;;;;;;;;;;;;;;;;;;;
Plattformen 1;Adopt;Platforms;FALSCH;Beschreinung Plattformen 1;;;;;;;;;;;;;;;;;;;;;
Plattformen 2;Adopt;Platforms;FALSCH;Beschreinung Plattformen 2;;;;;;;;;;;;;;;;;;;;;
Plattformen 3;Trial;Platforms;WAHR;Beschreinung Plattformen 3;;;;;;;;;;;;;;;;;;;;;
Plattformen 4;Trial;Platforms;FALSCH;Beschreinung Plattformen 4;;;;;;;;;;;;;;;;;;;;;
Plattformen 5;Trial;Platforms;WAHR;Beschreinung Plattformen 5;;;;;;;;;;;;;;;;;;;;;
Plattformen 6;Trial;Platforms;FALSCH;Beschreinung Plattformen 6;;;;;;;;;;;;;;;;;;;;;
Plattformen 7;Trial;Platforms;WAHR;Beschreinung Plattformen 7;;;;;;;;;;;;;;;;;;;;;
Plattformen 8;Trial;Platforms;WAHR;Beschreinung Plattformen 8;;;;;;;;;;;;;;;;;;;;;
Plattformen 9;Trial;Platforms;WAHR;Beschreinung Plattformen 9;;;;;;;;;;;;;;;;;;;;;
Plattformen 10;Trial;Platforms;WAHR;Beschreinung Plattformen 10;;;;;;;;;;;;;;;;;;;;;
Sennheiser 4600;Adopt;Tools;FALSCH;"<p><a href=""https://docs.greatexpectations.io/en/latest/""><strong>Great Expectations</strong></a> has become a sensible default for our teams in the data quality space, which is why we recommend adopting it ? not only for the lack of better alternatives but also because our teams have reported great results in several client projects. Great Expectations is a framework that allows you to craft built-in controls that flag anomalies or quality issues in data pipelines. Just as unit tests run in a build pipeline, Great Expectations makes assertions during the execution of a data pipeline. We like its simplicity and ease of use ? the rules stored in JSON can be modified by our data domain experts without necessarily needing data engineering skills.</p>";;;;;;;;;;;;;;;;;;;;;
Shure Gugus;Adopt;Tools;FALSCH;"<p>Since we first mentioned it in the Radar, <a href=""https://k6.io/""><strong>k6</strong></a> has become a go-to tool for performance testing. We continue to be fans of how easy it is to write JavaScript code for tests, but k6 also has a low-code <a href=""https://k6.io/docs/test-authoring/test-builder"">test builder</a> to make playing with the tool even easier. The documentation shows how easy it is to add performance testing to a pipeline across <a href=""https://k6.io/docs/integrations/#continuous-integration-and-continuous-delivery"">multiple CI/CD tools</a>. Our teams find it easy to integrate <a href=""https://k6.io/docs/integrations/#result-store-and-visualization"">visualization tools</a> like <a href=""/radar/tools/grafana"">Grafana</a> and New Relic, which help them tune both infrastructure and applications. The developer friendliness and ecosystem make k6 a compelling option for investigating a system's behavior under heavy load.</p>";;;;;;;;;;;;;;;;;;;;;
AVX;Trial;Tools;FALSCH;"<p><strong><a href=""https://superset.apache.org/"">Apache Superset</a></strong> is a great business intelligence (BI) tool for data exploration and visualization to work with large data lake and data warehouse setups. It supports several <a href=""https://superset.apache.org/docs/databases/installing-database-drivers"">data sources</a> ? including AWS Redshift, <a href=""/radar/platforms/bigquery"">BigQuery</a>, Azure MS SQL, <a href=""/radar/platforms/snowflake"">Snowflake</a> and <a href=""/radar/platforms/clickhouse"">ClickHouse</a>. Moreover, you don't have to be a data engineer to use it; it's meant to benefit all engineers exploring data in their everyday work. For demanding use cases, we found it easy to scale Superset by deploying it in a <a href=""/radar/platforms/kubernetes"">Kubernetes</a> cluster. Since we last talked about it in the Radar, Superset has graduated as an Apache product, and we've seen great success in several projects.</p>";;;;;;;;;;;;;;;;;;;;;
Rhode;Trial;Tools;WAHR;"<p>When implementing robust, secure and reliable disaster recovery, it?s necessary to ensure that backups can't be deleted or altered before their expiry, either maliciously or accidentally. Previously, with AWS Backup, these policies and guarantees had to be implemented by hand. Recently, AWS has added the Vault Lock feature to ensure backups are immutable and untamperable. <a href=""https://docs.aws.amazon.com/aws-backup/latest/devguide/vault-lock.html""><strong>AWS Backup Vault Lock</strong></a> enforces retention and deletion policies and prevents even those with administrator privileges from altering or deleting backup files. This has proved to be a valuable addition and fills a previously empty space.</p>";;;;;;;;;;;;;;;;;;;;;
Evalution;Trial;Tools;WAHR;"<p>Multi-team account management is a challenge in AWS, especially in setup and governance; <a href=""https://aws.amazon.com/controltower""><strong>AWS Control Tower</strong></a> is an attempt to address this challenge. Our team has reported good results using it to manage accounts and access control for multiple teams in the organization through a single, centralized place.</p>";;;;;;;;;;;;;;;;;;;;;
EvoTech;Trial;Tools;WAHR;"<p>We've had success with <a href=""https://clumio.com/products/protect/""><strong>Clumio Protect</strong></a> for backing up AWS data, particularly S3. A commercial SaaS solution, Clumio Protect can also back up a range of other AWS services and stores the data offline where it is not accessible through the internet. Our teams responsible for handling data protection and recovery at massive scale found that Clumio Protect is easy to set up and maintain and far outperforms the native AWS Backup service when S3 buckets are particularly big.</p>";;;;;;;;;;;;;;;;;;;;;
bolero;Trial;Tools;WAHR;"<p>We've been talking about <a href=""/radar/techniques/tailored-service-templates"">tailored service templates</a> ever since we first identified <a href=""/radar/techniques/microservices"">microservices</a> as a thing. If an organization sets out to create a collection of small services that can be developed, built, deployed and operated independently but consistently, it makes sense to give teams a solid starting point that aligns to the standard. However, one of the enduring problems with that approach is that as the template evolves over time in response to changing technical and business requirements, projects based on older versions of the template fall out of date. Retrofitting template improvements into an established project becomes a major pain. <strong><a href=""https://cruft.github.io/cruft/"">Cruft</a></strong> attempts to address this problem by providing tools to identify and patch differences between a local project and the current head of a master template repository. It combines the <a href=""https://github.com/cookiecutter/cookiecutter"">Cookiecutter</a> templating engine with git hashes to identify and apply changes to the templates. Think of it as a package manager for a project boilerplate. Keeping templates up-to-date is a notoriously difficult and long-standing problem, so to us the solution Cruft provides sounds almost too good to be true. Based on early feedback from our team, however, Cruft actually works and makes life easier for service builders and maintainers. We're anxious to see how it performs over the long term, but for now it's worth taking a look at this potentially useful tool.</p>";;;;;;;;;;;;;;;;;;;;;
GerÑte 8;Trial;Tools;FALSCH;"<p>We continue to hear enthusiastic reports about <strong><a href=""https://excalidraw.com/"">Excalidraw</a></strong> from our teams, but our previous caveat about security remains in place. Excalidraw is a simple yet powerful online drawing tool. Sometimes teams just need a quick picture instead of a formal diagram; for remote teams, Excalidraw provides a quick way to create and share diagrams. Our teams also like the ""lo-fi"" look of the diagrams it can produce, which is reminiscent of the whiteboard diagrams they would have produced when co-located. Regarding security, at the time of writing, anyone who has the link can see your diagrams; note, though, that the paid version of Excalidraw provides further authentication and options to run a server locally do exist.</p>";;;;;;;;;;;;;;;;;;;;;
GerÑte 9;Trial;Tools;WAHR;"<p>We like spreading the word about linting tools that actually help you find issues rather than just shortcut style disputes in the team. <strong><a href=""https://github.com/hadolint/hadolint"">Hadolint</a></strong> is one of those tools ? it helps find common issues in Dockerfiles. We find it to be fast, accurate and with good documentation. It explains both how to fix an issue and why it's an issue in the first place, thus nudging Dockerfile authors toward good practices. Incidentally, Hadolint is built on top of <a href=""/radar/tools/shellcheck"">ShellCheck</a>, which we recommend in its own right for checking your shell scripts.</p>";;;;;;;;;;;;;;;;;;;;;
GerÑte 10;Trial;Tools;WAHR;"<p>Most of today's CI/CD pipeline tools and platforms are built on containers as runtimes. Many of our teams are using <strong><a href=""https://github.com/GoogleContainerTools/kaniko"">Kaniko</a></strong> to build container images from within those container-based pipelines. This comes as part of a trend away from <a href=""/radar/platforms/docker"">Docker</a> as the de facto standard for container runtimes. With Kaniko, you can build your images without using a Docker daemon. This helps avoid the security issue of Docker's ""privileged"" mode, which would be necessary for any ""Docker-in-Docker"" activity. Moreover, you don't have to assume that your pipeline has access to a Docker daemon in the first place, which cannot be taken for granted anymore and often requires extra configuration.</p>";;;;;;;;;;;;;;;;;;;;;
sdfasdf;Trial;Tools;WAHR;"<p>As data work becomes more common, we continue to see tools that try to enhance the SQL language; <a href=""https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/""><strong>Kusto Query Language</strong></a> (KQL) is one of them. KQL was created by Azure, and it brings modularity, encapsulation, composability, reusability, extensibility and dynamism to relational querying. Our teams quite like its interactivity: you can pipe a query to the render operator and see a chart instantly. You can also combine these charts into dashboards and get insights from logs to execs in minutes. Although the KQL language is currently limited to the <a href=""https://azure.microsoft.com/en-us/products/data-explorer/#overview"">Azure Data Explorer</a>, we anticipate the move to enhance SQL to achieve better data operability will not stop.</p>";;;;;;;;;;;;;;;;;;;;;
io-ts;Adopt;languages-and-frameworks;FALSCH;"<p>Our teams developing in <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a> are finding <strong><a href=""https://gcanti.github.io/io-ts/"">io-ts</a></strong> invaluable, especially when interacting with APIs that ultimately result in the creation of objects with specific types. When working with TypeScript, getting data into the bounds of the type system (i.e., from the aforementioned APIs) can lead to run-time errors that can be hard to find and debug. io-ts bridges the gap between compile-time type checking and run-time consumption of external data by providing encode and decode functions. Given the experiences of our teams and the elegance of its approach, we think io-ts is worth adopting.</p>";;;;;;;;;;;;;;;;;;;;;
Kotest;Adopt;languages-and-frameworks;FALSCH;"<p><strong><a href=""https://kotest.io/"">Kotest</a></strong> (previously KotlinTest) is a stand-alone testing tool for the <a href=""/radar/languages-and-frameworks/kotlin"">Kotlin</a> ecosystem that is widely used among our teams across various Kotlin implementations ? native, JVM or JavaScript. Its key advantages are that it offers a variety of testing styles in order to structure test suites and that it comes with a comprehensive set of matchers, which allow for expressive tests in an elegant internal DSL. In addition to its support for <a href=""/radar/techniques/property-based-unit-testing"">property-based testing</a>, our teams like the solid IntelliJ plugin and the support community. Many of our developers consider it their first choice and recommend those who are still using JUnit in Kotlin consider switching over to Kotest.</p>";;;;;;;;;;;;;;;;;;;;;
NestJS;Adopt;languages-and-frameworks;FALSCH;"<p>In the past, we've cautioned about <a href=""/radar/platforms/node-overload"">Node overload</a>, and we're still cautious about the reasons to choose it. However, in scenarios where Node.js is required to build back-end applications, our teams are reporting that <strong><a href=""https://nestjs.com/"">NestJS</a></strong> is a suitable option to enable developers to create testable, scalable, loosely coupled and easily maintainable applications in enterprises. NestJS is a <a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a>-first framework that makes the development of Node.js applications safer and less error-prone. NestJS is opinionated and comes with SOLID principles and an <a href=""/radar/languages-and-frameworks/angular"">Angular</a>-inspired architecture out of the box.</p>";;;;;;;;;;;;;;;;;;;;;
React Query;Adopt;languages-and-frameworks;FALSCH;"<p><a href=""https://react-query-v3.tanstack.com/""><strong>React Query</strong></a> is often described as the missing data-fetching library for <a href=""/radar/languages-and-frameworks/react-js"">React</a>. Fetching, caching, synchronizing and updating server state is a common requirement in many React applications, and although the requirements are well understood, getting the implementation right is notoriously difficult. React Query provides a straightforward solution using hooks. It works hand-in-hand with existing async data-fetching libraries like <a href=""/radar/tools/axios"">axios</a>, <a href=""/radar/languages-and-frameworks/fetch"">Fetch</a> and <a href=""/radar/languages-and-frameworks/graphql"">GraphQL</a> since they are built on promises. As an application developer, you simply pass a function that resolves your data and leave everything else to the framework. We like that it works out of the box but still offers a lot of configuration when needed. The developer tools, unfortunately not yet available for <a href=""/radar/languages-and-frameworks/react-native"">React Native</a>, also help developers new to the framework understand how it works. For React Native, you can use a <a href=""https://github.com/bgaleotti/react-query-native-devtools"">third-party developer tools plugin</a> utilizing <a href=""/radar/tools/flipper"">Flipper</a>. In our experience, version 3 of React Query brought the stability needed to be used in production with our clients.</p>";;;;;;;;;;;;;;;;;;;;;
Swift Package Manager;Adopt;languages-and-frameworks;FALSCH;"<p>When introduced in 2014, Swift didn't come with a package manager. Later, <strong><a href=""https://github.com/apple/swift-package-manager"">Swift Package Manager</a></strong> was created as an official Apple open-source project, and this solution has continued to develop and mature. Our teams rely increasingly on SwiftPM because most packages can be included through it and the processes for both creators and consumers of packages have been streamlined. In the previous Radar, we recommended trialing, but we now believe it makes sense to select it as the default when starting new projects. For existing projects using tools like CocoaPods or <a href=""/radar/tools/carthage"">Carthage</a>, it might be worth a quick experiment to gauge the level of effort to migrate and to check whether all dependencies are available.</p>";;;;;;;;;;;;;;;;;;;;;
Yjs;Adopt;languages-and-frameworks;WAHR;"<p>Conflict-free replicated data type (CRDT) algorithms are proven to be able to automatically distribute and merge changes among peers without conflicts. But in practice, even for small enough data, these algorithms usually require a significant amount of memory to trace all the changes made by different peers, thus making them impractical. <strong><a href=""https://yjs.dev/"">Yjs</a></strong> is a carefully optimized CRDT implementation that keeps memory consumption at a reasonable level for large data sets and millions of modifications. It also provides bindings for popular text editors, which greatly reduce the cost of building collaborative tools.</p>";;;;;;;;;;;;;;;;;;;;;
Azure Bicep;Trial;languages-and-frameworks;FALSCH;"<p>For those who prefer a more natural language than JSON for infrastructure code, <strong><a href=""https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep"">Azure Bicep</a></strong> is a domain-specific language (DSL) that uses a declarative syntax and supports reusable parameterized templates for modular resource definitions. A <a href=""https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-bicep"">Visual Studio Code extension</a> provides instant type safety, intellisense and syntax checking, while the compiler allows bidirectional transpilation to and from Azure Resource Manager (ARM) templates. Bicep's resource-oriented DSL and native integration with the Azure ecosystem make it a compelling choice for Azure infrastructure development.</p>";;;;;;;;;;;;;;;;;;;;;
Camunda;Trial;languages-and-frameworks;FALSCH;"<p>Since we last mentioned <strong><a href=""https://camunda.com/"">Camunda</a></strong>, we've seen many of our teams and clients use the platform, making it one of our preferred workflow engines in cases where a workflow engine is a good fit for the domain. Camunda offers workflow and decision engines that can be integrated as a library in your Java code. This makes it easy to test, version and refactor workflows, alleviating some of the downsides of other more low-code workflow engines. We've even seen Camunda used in environments with high performance requirements. Teams also like how easy it is to integrate with <a href=""/radar/languages-and-frameworks/spring-boot"">Spring Boot</a> and its nice user interface.</p>";;;;;;;;;;;;;;;;;;;;;
Gradle Kotlin DSL;Trial;languages-and-frameworks;FALSCH;"<p>Previously, we blipped about the Android Gradle plugin Kotlin DSL, or <strong>Gradle Kotlin DSL</strong>, which added support for <a href=""/radar/languages-and-frameworks/kotlin"">Kotlin</a> Script as an alternative to <a href=""/radar/languages-and-frameworks/groovy"">Groovy</a> for Android projects using <a href=""/radar/tools/gradle"">Gradle</a> build scripts. The goal of replacing Groovy with Kotlin is to provide better support for refactoring and simpler editing in IDEs and, ultimately, to produce code that is easier to read and maintain. For teams already using Kotlin, it also means working on the build in a familiar language. We now suggest trialing Kotlin DSL as an alternative language to Groovy for Gradle projects in general, especially if you have large or complex Gradle build scripts. Many IDEs now include support for the migration of existing projects. Some caveats remain, and we suggest checking the <a href=""https://docs.gradle.org/current/userguide/kotlin_dsl.html"">documentation</a> for the most up-to-date details, including the prerequisites. We had a team with an at least seven-year-old, 450-line build script migrate successfully within a few days.</p>";;;;;;;;;;;;;;;;;;;;;
Jetpack Media3;Trial;languages-and-frameworks;FALSCH;"<p>Android had several media APIs: Jetpack Media, also known as MediaCompat, Jetpack Media2 and ExoPlayer. Unfortunately, these libraries were developed independently, with different goals but overlapping functionality. Android developers not only had to choose which library to use, they also had to contend with writing adaptors or other connecting code when features from multiple APIs were needed. <a href=""https://developer.android.com/jetpack/androidx/releases/media3""><strong>Jetpack Media3</strong></a> is an API that takes common areas of functionality from the existing APIs ? including UI, playback and media session handling ? and combines them into a merged and refined API. The player interface from ExoPlayer has also been updated, enhanced and streamlined to act as the common player interface for Media3. After an early access phase, Media3 is now in beta. Although its first release is forthcoming, we've already had positive experiences using it in apps.</p>";;;;;;;;;;;;;;;;;;;;;
Ladle;Trial;languages-and-frameworks;WAHR;"<p>As <a href=""https://storybook.js.org/"">Storybook</a> grew in popularity, it became more and more of a behemoth. If all you really care about is isolating and testing your React UI components, then <strong><a href=""https://ladle.dev/"">Ladle</a></strong> is the alternative. Ladle supports most of the Storybook API (MDX files are not supported yet) and can be used as a drop-in replacement. It is lightweight and has better integration with <a href=""https://vitejs.dev/"">Vite</a>. It also provides simple and clean APIs that can be easily integrated with other testing frameworks.</p>";;;;;;;;;;;;;;;;;;;;;
Moshi;Trial;languages-and-frameworks;WAHR;"<p>We're hearing that our <a href=""/radar/languages-and-frameworks/kotlin"">Kotlin</a>-based teams are seeking alternatives to Java frameworks such as GSON when handling JSON. Although it's been around for some time, <strong><a href=""https://github.com/square/moshi"">Moshi</a></strong> has now emerged as a preferred framework for many of these teams. It's easy to migrate from GSON and Moshi provides native support for Kotlin non-nullable types and default parameters. Moshi makes working with JSON faster and easier. If you're currently using a Java framework from within Kotlin to handle JSON, we recommend giving Moshi a try.</p>";;;;;;;;;;;;;;;;;;;;;
Svelte;Trial;languages-and-frameworks;FALSCH;"<p>Among web component frameworks, <strong><a href=""https://svelte.dev/"">Svelte</a></strong> stands out by moving reactivity out of the browser and into the compiler. Instead of optimizing DOM updates by using a virtual DOM and browser optimization tricks, Svelte compiles your code into vanilla framework-less JavaScript code that surgically updates the DOM directly. In addition to the run-time performance benefits, this also allows Svelte to optimize the amount of code the browser has to download without sacrificing features for developers; moreover, it's proven to be performant and battery-friendly for mobile web applications as less code has to execute in the browser itself. Performance benefits aside, our teams have appreciated its friendly learning curve and the maintenance benefits that come from <a href=""https://svelte.dev/blog/write-less-code"">writing less code</a>. Svelte itself is only the component framework, but <a href=""https://kit.svelte.dev/"">SvelteKit</a> adds features to build full web applications.</p>";;;;;;;;;;;;;;;;;;;;;
Aleph.js;Assess;languages-and-frameworks;WAHR;"<p>There is certainly no shortage of frameworks to build web applications in JavaScript/<a href=""/radar/languages-and-frameworks/typescript"">TypeScript</a>. We've featured many of them in the Radar, but what sets <strong><a href=""https://alephjs.org/docs"">Aleph.js</a></strong> apart in this crowded field is that it's built to run on <a href=""/radar/platforms/deno"">Deno</a>, the new server-side run time created by the original developer of <a href=""/radar/platforms/node-js"">Node</a>. This puts Aleph.js on a modern foundation that addresses several shortcomings and problems with Node. Aleph.js is still new ? it?s approaching the 1.0 release at the time of writing ? but it already offers a solid developer experience, including hot module replacement. With Deno now way past its <a href=""https://deno.com/blog/v1"">1.0 release</a>, this is a modern choice for projects that can take the risk.</p>";;;;;;;;;;;;;;;;;;;;;
Astro;Assess;languages-and-frameworks;WAHR;"<p>It's hard to believe, but in 2022, the developer community continues to pump out interesting new frameworks for building web applications. <strong><a href=""https://astro.build/"">Astro</a></strong> is a recent, open-source, multi-page application framework that renders HTML on the server and minimizes the amount of JavaScript sent over the wire. Astro seems particularly well-suited to content-oriented websites that pull from many different sources. We like the fact that although Astro encourages sending only HTML, it still supports ? when appropriate ? select active components written in the front-end JavaScript framework of your choice. It does this through its <a href=""https://mainawycliffe.dev/blog/island-architecture/"">island architecture</a>. Islands are regions of interactivity within a single page where the necessary JavaScript is downloaded only when needed. Astro is relatively new but seems to support a growing ecosystem of developers and code. It's one to watch as it develops.</p>";;;;;;;;;;;;;;;;;;;;;
Codeplug;Assess;languages-and-frameworks;WAHR;"<p><a href=""https://github.com/bentoml/BentoML""><strong>BentoML</strong></a> is a python-first framework for serving machine-learning models in production at scale. The models it provides are agnostic of their environment; all model artifacts, source code and dependencies are encapsulated in a self-contained format called Bento. It's like having your model ""as a service."" Think of BentoML as the <a href=""/radar/platforms/docker"">Docker</a> for ML models: It generates VM images with pre-programmed APIs ready for deployment and includes features that make it easy to test these images. BentoML can help speed up the initial development effort by easing the start of projects which is why we included it in Assess.</p>";;;;;;;;;;;;;;;;;;;;;
Frameworks 2;Assess;languages-and-frameworks;WAHR;"<p>When looking at reducing the carbon footprint of an application ? the carbon dioxide emissions caused indirectly by running the software ? attention is usually directed at making the software more efficient. The thinking is clear: more efficient software needs less electricity and fewer servers, reducing the emissions from electricity generation and manufacturing of the servers. An additional strategy is to make the application <em>carbon aware</em>. This is because the same workload does not always have the same carbon footprint. For example, when run in a data center in a cooler climate, less power for air conditioning is needed; or, when run at a time when more renewable energy is available (more sunshine, stronger winds), less electricity from carbon-based  sources is required. With the <a href=""https://github.com/Green-Software-Foundation/carbon-aware-sdk""><strong>Carbon Aware SDK</strong></a>, software engineers can query data sources to discover less carbon-intensive options for a given workload and then move it to a different location or run it at a different time. This makes sense for large workloads that are neither time nor latency sensitive, such as training a machine-learning model. Although the SDK and available data sources are not very comprehensive yet, we believe it's time to start looking at how we can make our systems carbon aware.</p>";;;;;;;;;;;;;;;;;;;;;
Frameworks 3;Assess;languages-and-frameworks;WAHR;"<p><strong><a href=""https://cloudscape.design/"">Cloudscape</a></strong> is an open-source design system that not only has a rich set of components but also 35 interaction and content representation patterns. In addition, it uses <a href=""/radar/techniques/design-tokens"">design tokens</a> for theming and provides element wrappers for all components, which greatly simplifies unit testing. This makes it stand out from other design systems out there.</p>";;;;;;;;;;;;;;;;;;;;;
Frameworks 4;Assess;languages-and-frameworks;WAHR;"<p><a href=""https://connect.build/""><strong>Connect</strong></a> is a family of libraries for building browser- and gRPC-compatible HTTP APIs. Similar to gRPC, you write Protocol Buffer schema and implement the application logic, and Connect generates code to handle marshaling, routing, compression and content type negotiation. However, Connect tries to improve on gRPC in several ways. This includes native support for gRPC-Web without a translating proxy; interoperability with third-party routers or middleware, because <a href=""https://github.com/bufbuild/connect-go"">connect-go</a> is built on top of net/http (unlike grpc-go); and fully generated type-safe clients with the ergonomics of hand-crafted code. We mostly prefer REST and are not a big fan of the RPC approach to building APIs. That said, Connect does seem to address some of our concerns with RPCs, and we encourage you to assess it.</p>";;;;;;;;;;;;;;;;;;;;;
Frameworks 5;Assess;languages-and-frameworks;WAHR;"<p>As smart devices continue to embed themselves in our lives, we are starting to see new use cases emerge that span across multiple devices. The classic example is a text we start reading on a phone but prefer to finish on a tablet. Other examples include plotting a cycling route on a laptop and then transferring the data to a bike computer for easier navigation or using a mobile phone as a webcam. Such use cases require very specific kinds of features, like the discovery of nearby devices, secure communication and multi-device sessions. Apple started introducing such features a while ago to its own SDKs, and now Google has released the first preview of its <a href=""https://developer.android.com/guide/topics/connectivity/cross-device-sdk/overview""><strong>Cross device SDK</strong></a>. Although the preview has several limitations ? for example, only phones and tablets are supported and only two devices at a time ? the technology is exciting and can be utilized as it is rolled out over time.</p>";;;;;;;;;;;;;;;;;;;;;
Frameworks 6;Assess;languages-and-frameworks;WAHR;"<p><a href=""https://docs.cypress.io/guides/component-testing/writing-your-first-component-test""><strong>Cypress Component Testing</strong></a> provides a testable component workbench to quickly build and test UI components. You can write component visual regression tests with the same API that you write end-to-end (E2E) UI tests. Although still in beta, component testing will be the most important feature in <a href=""/radar/tools/cypress"">Cypress</a> 10.</p>";;;;;;;;;;;;;;;;;;;;;
Frameworks 7;Assess;languages-and-frameworks;WAHR;"<p><strong><a href=""https://www.jobrunr.io/"">JobRunr</a></strong> is a library for background job processing in Java and an alternative to the Quartz scheduler. Our teams have enjoyed using JobRunr's built-in dashboard, which is easy to use and allows the monitoring and scheduling of background tasks. JobRunr is open source and free for commercial use; for features such as job migration and recovery, however, you need to get a paid license.</p>";;;;;;;;;;;;;;;;;;;;;
asdf;Masse;der 5.;FALSCH;asdf;;;;;;;;;;;;;;;;;;;;;
